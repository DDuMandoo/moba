# 📌 목차
- [2025.03.04 TIL](#20250304-til)
- [2025.03.05 TIL](#20250305-til)
- [2025.03.06 TIL](#20250306-til)

---

## 2025.03.04 TIL

### Today's Keywords
`아이디어` `DB`

### 오늘 배운 것

1. 아이디어 회의 및 구체화
    - 반려동물 금융 서비스 아이디어 구체화

2. MySQL 아키텍처
    ## 아키텍처

### 1. MySQL 엔진 아키텍처

- MySQL 전체 구조
    - C API, JDBC, ODBC, .NET과 같은 표준 드라이버 제공
        
        → 모든 언어로 MySQL 서버에서 쿼리 사용 지원

- MySQL 엔진
    - 요청된 SQL문장을 분석하거나 최적화, DBMS의 두뇌에 해당하는 처리 수행
    - 커넥션 헨들러 : 클라이언트 접속 및 쿼리 요청을 처리
    - SQL 파서 : 쿼리문 해석 및 분석
    - 전처리기
    - 옵티마이저 : 쿼리의 최적화된 실행
- 스토리지 엔진
    - 실제 데이터를 디스크 스토리지에 저장, 디스크 스토리지로부터 데이터를 읽어옴
    - **버퍼 풀(Buffer Pool)** 은 **MySQL의 InnoDB 스토리지 엔진이 디스크에서 데이터를 읽어와 메모리에 캐싱하는 영역**
    - InnoDB vs MyISAM
        
        ✅ **InnoDB 추천 (거의 모든 경우)**
        
        - 트랜잭션이 필요할 때
        - 데이터 무결성이 중요한 경우 (은행, 쇼핑몰 등)
        - 동시 사용자가 많아야 하는 서비스
        
        ✅ **MyISAM 추천 (특수한 경우만)**
        
        - 트랜잭션이 필요 없고, **읽기 성능이 가장 중요**할 때
        - 데이터 변경이 거의 없고 **조회만 하는 로그 저장소**
        - `FULLTEXT INDEX`(InnoDB도 지원하지만 MyISAM이 더 최적화됨)
- 핸들러 API
    - 핸들러 요청 : 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청
- MySQL 스레딩 구조
    
    - MySQL은 스레드기반 동작
    - 포그라운드 스레드(사용자 스레드)
        - 최소한 MySQL 서버에 접속한 클라이언트의 수만큼 존재 → 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리 → 커넥션 종료, 스레드 캐시로 돌아감
            - 스레드 캐시에는 일정 개수의 스레드 유지, 개수가 넘어가면 캐시에 넣지 않고 종료
        - 데이터를 데이터 버퍼나 캐시로부터 가져옴
            - MyISAM : 디스크 쓰기 작업까지 처리
            - InnoDB : 데이터 버퍼나 캐시까지만 처리
    - 백그라운드 스레드
        - InnoDB
            - 인서트 버퍼를 병합하는 스레드
            - 로그를 이스크로 기록하는 스레드
            - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
            - 데이터를 버퍼로 읽어오는 스레드
            - 잠금이나 데이터락을 모니터링하는 스레드
            - 쓰기 작업을 버퍼링해서 일괄 처리하는 기능 탑재
- 메모리 할당 및 사용 구조
    - 글로벌 메모리
        - 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당
        - 모든 스레드에 의해 공유
        - 대표적인 글로벌 메모리 영역
            - 테이블 캐시
            - InnoDB 버퍼 풀
            - InnoDB 어댑티브 해시 인덱스
            - InnoDB 리두 로그 버퍼
    - 로컬 메모리(세션 메모리, 클라이언트 메모리)
        - MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
        - 각 클라이언트 스레드별로 독립적으로 할당, 공유 X
        - 대표적인 로컬 메모리 영역
            - 정렬 버퍼
            - 조인 버퍼
            - 바이너리 로그 캐시
            - 네트워크 버퍼
- 플러그인 스토리지 엔진 모델
    - MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 헨들러를 통해야 한다
        - 핸들러 : MySQL엔진이 스토리지 엔진을 조정하기 위해 사용
- 컴포넌트
    - 플러그인의 단점
        - 오직 MySQL서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
        - MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
        - 상호 의존 관계를 설정X, 초기화가 어려움
    - 플러그인의 단점을 보완하기 위해 컴포넌트 구현
- 쿼리 실행 구조
    
    - 쿼리파서
        - 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어내는 작업
        - 쿼리 문법 오류 발견 및 오류 메세지 전달
    - 전처리기
        - 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
        - 객체를 매핑 → 해당 객체의 존재 여부와 접근 권한을 확인
    - 옵티마이저
        - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할
    - 실행 엔진
        - 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할
    - 핸들러(스토리지 엔진)
        - 실행 엔진의 요청에 따라 데이터를 디스크에 저장하고 읽어오는 역할을 담당
- 쿼리 캐시
    - 실행 결과를 메모리에 캐시 → 동일 SQL 쿼리가 실행되면 즉시 결과를 반환
    
    → 테이블의 데이터가 변형되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된것을 모두 삭제 → 심각한 동시 처리 성능 저하 유발
    
- 스레드 풀
    - MySQL 엔터프라이즈에서만 지원
    - 커뮤니티 버전 → PerconaServer 플러그인으로 사용
    - 사용자 요청을 처리하는 스레드 개수를 줄여서 MySQL서버의 CPU가 제한된 개수의 스레드 처리에만 집중하게 해 서버의 자원 소모를 줄이는 것
    - Percona Server
        - CPU 코어의 개수만큼 스레드 그룹을 생성 → CPU 프로세서 친화도를 높이는 데 좋음
        - 스레드 그룹의 모든 스레드가 모두 작업중인 경우
            - 기존 작업 스레드가 처리를 완료하기를 기다림
            - 새로운 작업 스레드 추가
        - 선순위 큐와 후순위큐를 이용해 특정 트랜젝션이나 쿼리를 우선적으로 처리하는 기능
- 트랜잭션 지원 메타데이터
    - 매터데이터 : 데이터 베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보
    - 8.0 부터 InnoDB의 테이블에 저장 → 스키마 변경 중 비정상 종료 된 경우 스키마 변경이 완전한 성공 또는 완전한 실패로 나뉨

### InnoDB 스토리지 엔진 아키텍처

InnoDB → 레코드 기반의 잠금을 제공, 높은 동시성 처리 가능 안정적이며 선능이 뛰어남

- 프라이머리 키에 의한 클러스터링
    - 프라이머리 키 값의 순서대로 디스크에 저장 → 프라이머리 키를 기준으로 클러스터링 되어 저장
- 외래 키 지원
    - 외래 키는 서버 운영의 불편함 때문에 서비스 데이터베이스에서는 생성하지 않는 경우도 있음 개발 환경에서는 좋은 가이드 역할을 함
    - 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요
- MVCC(Multi Version Concurrency Control)
    - 잠금을 사용하지 않는 일관된 읽기를 제공
    - 하나의 레코드에 대해 변경이 일어나면 2개의 버전(커밋 전과 후)이 유지되고 필요에 따라 어느 데이터가 보여지는지 달라지는 구조
- 잠금 없는 일관된 읽기
    - 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다
    - 변경 전 데이터 → 언두 로그
    - 활성된 트랜잭션 → 서버가 느려지는 문제 유발
        - 언두 로그를 유지해야하기 때문에 발생
        - 가능한 빠르게 롤백이나 커밋으로 트랜잭션 완료
- 자동 데드락 감지
    - 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리
    - 잠금 대기 그래프를 검사해 고착 상태에 빠진 트랜잭션들을 찾아가 그 중 하나를 강제 종료
        - 언두 로그 양으로 종료할 트램젝션 판단
- 자동화된 장애 복구
    - 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지에 대한 일련의 복구 작업이 자동으로 진행

---

## 2025.03.05 TIL

### Today's Keywords
`아이디어`

### 오늘 배운 것

1. 아이디어 회의 및 구체화
    - 반려동물 금융 서비스 아이디어 구체화
        - 반려동물 건강 분석 AI자료 조사

---

## 2025.03.06 TIL

### Today's Keywords
`아이디어` `알고리즘`

### 오늘 배운 것

1. 아이디어 회의 및 구체화
    - 모임 계획 서비스
        - 아이디어 구체화
        - 활용 데이터 수집

2. 알고리즘 
    이분 탐색(Binary Search)은 정렬된 배열에서 특정 값을 빠르게 찾는 알고리즘입니다.

    - 개념
        배열의 가운데 값을 기준으로 찾고자 하는 값과 비교합니다.찾고자 하는 값이 가운데 값보다 크면 오른쪽 절반을 탐색하고, 작으면 왼쪽 절반을 탐색합니다.이 과정을 반복하여 원하는 값을 찾거나 탐색 범위를 줄여서 종료합니다.

    - 시간 복잡도
        O(log N) → 탐색 범위가 절반씩 줄어들기 때문에 매우 빠름

