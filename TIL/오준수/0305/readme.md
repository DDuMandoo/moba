# ORM

## 1. ORM(Object-Relational Mapping)이란?

- ORM(Object-Relational Mapping)은 객체 지향 프로그래밍에서 사용하는 **객체**를 데이터베이스의 **테이블**과 매핑하여, 프로그래머가 직접 SQL을 작성하지 않고도 데이터베이스 조작(CRUD) 작업을 수행할 수 있도록 도와주는 기술
- **객체**: Java 등 OOP 언어에서 사용하는 클래스의 인스턴스(예: `User`, `Order` 등).
- **테이블**: RDB(Relational DataBase)에서 데이터를 행과 열로 구성하여 저장하는 구조(예: `users`, `orders` 테이블).

ORM을 사용하면, 데이터 조회나 저장 시 직접 SQL을 작성하기보다는 **ORM 프레임워크가 제공하는 메서드**나 **쿼리 빌더** 등을 사용해서 객체 중심으로 코드를 작성하게 된다. ORM 프레임워크가 내부적으로 SQL을 생성하고 실행해주어, **개발자가 비즈니스 로직에만 집중**할 수 있게 해준다는 장점이 있다.

---

## 1-1. JPA와 Hibernate, Spring Data JPA의 차이

### (1) JPA (Java Persistence API)

- **JPA**는 자바 표준 ORM 기술 규약(스펙)입니다.
- 인터페이스와 애노테이션으로만 구성되어 있으며, 실제 구현체가 필요합니다.
- 예: `javax.persistence.*` 혹은 최신 버전에서는 `jakarta.persistence.*` 패키지 내에 있는 것들이 JPA 표준 인터페이스/애노테이션.

### (2) Hibernate (JPA 구현체 중 하나)

- **Hibernate**는 JPA를 구현한 가장 대표적인 ORM 프레임워크(구현체)이다.
- 단독으로 써도 되지만( Hibernate 고유 기능도 활용 가능), 보통은 “Hibernate”를 JPA 표준에 맞춰 사용한다.
- JPA에서 선언한 스펙을 Hibernate가 실제 기능(라이브러리)로 제공하는 것이다.

### (3) Spring Data JPA

- **Spring Data JPA**는 JPA를 **좀 더 편리하고 간단하게** 사용하도록 도와주는 스프링 생태계의 라이브러리다.
- **Spring Data** 시리즈 중 JPA 기술을 사용하는 부분을 추상화한 것이 **Spring Data JPA**이다.
    - **인터페이스 기반의 Repository** 자동 구현
    - 더 편리한 쿼리 메서드 (ex. `findByUsername(String username)` 같이 메서드 이름 기반으로 쿼리 생성)
    - 페이징, 정렬, 특정 쿼리 작성(메서드명, JPQL, QueryDSL 연동 등) 기능 제공

---

## 2. ORM 사용 이유 (자바와 SQL 작성 방식의 차이)

### (1) 객체 지향적인 개발

- 자바는 객체 지향 언어이므로, **비즈니스 로직**이 대부분 객체를 중심으로 돌아감.
- ORM을 사용하면, 객체와 데이터베이스 테이블을 1:1로 매핑하여 데이터 조작할 때 **객체**를 직접 다룸.
- “객체를 통해 데이터베이스에 접근한다”는 느낌 → SQL 문자열을 코드에서 반복적으로 작성하지 않아도 됨.

### (2) 생산성, 유지보수성 향상

- 순수 JDBC or MyBatis는 매번 SQL을 짜고, 결과 매핑을 직접 해주어야 함.
- → 대규모 프로젝트에서는 **SQL 반복, 중복 코드**가 굉장히 많아지고, DB 스키마 변경 시 수정 포인트가 엄청나게 늘어나 유지보수가 어려움.
- ORM은 이런 반복 작업을 최소화하고, **엔티티(객체) 필드 변경 → DDL 자동 생성, 동적 쿼리 등**을 지원하므로 생산성과 유지보수가 용이해짐.

### (3) DB 변경의 유연성

- JPA/Hibernate는 DB 벤더에 의존적이지 않도록 추상화되어 있음.
- 다른 데이터베이스로 전환할 때 SQL 문법 차이가 덜 신경 쓰이므로, 이식성이 좋아짐. (ORM에 맡기면 어느 정도 호환 쿼리를 생성해 주는 편)

---

## 3. JDBC와 MyBatis 돌아보기

### (1) JDBC

- JDBC(Java Database Connectivity)는 자바에서 **데이터베이스에 접근**할 수 있도록 해주는 **저수준 API**이다.
- `Connection`, `Statement/PreparedStatement`, `ResultSet` 등을 사용해 직접 SQL 작성, 실행 후 결과를 매핑해야 한다.
- 장점
    - 직접 SQL을 작성하므로 **세밀한 최적화**가 가능.
    - **디버깅이 간단**하고 SQL 로그를 있는 그대로 확인 가능.
- 단점
    - 반복 코드가 많고, SQL 작성/수정에 따른 유지보수가 어렵다.
    - 객체 매핑을 매번 수동으로 해주어야 한다.

### (2) MyBatis

- **MyBatis**는 JDBC를 **SQL Mapper** 방식으로 좀 더 편리하게 사용할 수 있게 해 주는 프레임워크다.
- **XML** 혹은 **애노테이션**으로 SQL을 미리 작성하고, DAO 인터페이스와 매핑해서 호출만 하면 된다.
- 장점
    - 여전히 **SQL을 직접 작성**하지만, 매퍼 XML + 객체 매핑 기능을 통해 반복 코드를 대폭 제거.
    - 복잡한 쿼리 작성에 유리.
- 단점
    - “SQL 중심”이기 때문에, 많은 테이블의 CRUD를 전부 작성해야 한다면 여전히 SQL량이 많아질 수 있음.
    - 스키마 변경 시 SQL 파일 일일이 수정 필요.

---

## 4. JDBC vs. MyBatis vs. ORM(JPA/Hibernate)

| 비교 항목 | JDBC | MyBatis | ORM(JPA/Hibernate) |
| --- | --- | --- | --- |
| **SQL 작성** | 직접 PreparedStatement로 작성 | XML/애노테이션으로 작성, 매퍼 매핑 | 기본 CRUD에 대해서는 거의 작성하지 않음 (필요시 JPQL, Native SQL) |
| **개발 생산성** | 매우 낮음 (중복코드 많음) | 중간 (SQL 문서를 통해 반복 제거, 코드량 감소) | 높음 (CRUD 자동화, 객체 중심 개발) |
| **유지보수** | 어렵다. SQL 변경 시 코드 연쇄 수정 필요 | 중간. 매퍼 XML/애노테이션 수정 필요 | 비교적 쉽다. 엔티티 변경 시 ORM이 DDL/SQL 자동 생성(옵션) |
| **러닝 커브** | 낮음 (기본 JDBC이므로 단순) | 중간 (매퍼 XML, 설정) | 높음 (엔티티 매핑, 영속성 컨텍스트, 지연 로딩, 캐시 등 개념 많음) |
| **성능 최적화** | 세밀한 제어 가능 (직접 SQL 작성) | SQL 직접 작성 가능 | 자동으로 SQL을 생성하지만, 상황별 튜닝 필요 (JPQL, Fetch 전략 등) |
| **복잡한 쿼리** | 작성 가능 (하지만 코드 중복多) | 가장 용이 (SQL 그대로 작성 가능) | 가능은 하지만 JPQL/QueryDSL 문법 익숙해져야 함 |
- **ORM**: 코드량이 가장 적고 객체지향적인 모델링이 가능하나, 러닝 커브가 있고(학습 난이도) 고급 튜닝이 필요한 순간에는 ORM 메커니즘을 잘 이해해야 한다.

---

## 5. 언제 ORM(JPA)을 써야 하는가?

1. **도메인이 복잡하고, 엔티티 중심의 비즈니스 로직**이 많은 경우
    - 예: 대규모 프로젝트, 여러 테이블 간의 연관관계(1:N, N:N 등)가 복잡하고, 객체 단위로 데이터를 다루는 로직이 많을 때
    - ORM이 연관관계 매핑, 지연 로딩, 캐시 등 기능을 활용하여 높은 생산성을 제공
2. **생산성과 유지보수가 중요한 경우**
    - 예: “프로토타입을 빠르게 만들고, 유지보수를 장기적으로 해야 하는 시스템”
    - 표준 JPA + Spring Data JPA를 사용하면, DB 스키마나 엔티티 수정 시에도 상당 부분 자동화가 가능.
3. **DB 벤더를 자주 바꾸거나, 특정 DB 종속 로직을 최대한 줄이고 싶은 경우**
    - 예: “개발/운영 환경이 상이”, “RDB 간 옮겨갈 가능성 있음”
    - ORM은 SQL을 추상화하여 어느 정도 호환성 보장.
4. **복잡한 쿼리보다 CRUD/연관관계 트랜잭션이 중심인 경우**
    - 복잡한 통계/집계 쿼리가 주가 되면, 대형 SQL을 직접 다뤄야 해서 ORM의 장점이 감소할 수 있다.
    - 그러나 도메인 모델로 CRUD, 연관관계 작업이 많은 프로젝트라면 ORM은 큰 이점이 있음.

### 반면에, 아래와 같은 경우는 MyBatis나 JDBC가 더 나을 수도 있음

- **SQL에 대한 완전한 제어가 필요**하고, 복잡한 수작업 튜닝이 많고(예: DB 오라클 특정 인덱스 힌트, 분산 DB 아키텍처 등).
- **매우 복잡한 통계, 집계 쿼리** 위주 시스템 (BI/OLAP 성격).
- **기존에 쿼리가 이미 방대**하게 작성되어 있어, JPA로 마이그레이션하기에 이점이 적거나 리스크가 큰 경우.